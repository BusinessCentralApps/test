name: Context

on:
  workflow_dispatch:

defaults:
  run:
    shell: pwsh

jobs:
  update:
    runs-on: windows-latest
    defaults:
      run:
        shell: powershell

    steps:
      - name: ComputerInfo
        run: |
          Get-ComputerInfo | Out-Host

      - name: ENV
        run: |
          Write-Host "ModulePath: '$ENV:PSModulePath'"
          Write-Host "GITHUB_EVENT_PATH: '$ENV:GITHUB_EVENT_PATH'"
          Get-Module Az.KeyVault -ListAvailable         
          Get-Module AzureRM.KeyVault -ListAvailable         

      - name: Remove AzureRM
        run: |
          $azModulesPath = Get-ChildItem 'C:\Modules\az_*' -Directory
          if ($azModulesPath) {
            Write-Host $azModulesPath.FullName
            $ENV:PSModulePath = "$($azModulesPath.FullName);$(("$ENV:PSModulePath".Split(';') | Where-Object { $_ -notlike 'C:\\Modules\Azure*' }) -join ';')"
            Add-Content -Path $env:GITHUB_ENV -Value "PSModulePath=$ENV:PSModulePath"
            Write-Host $ENV:PSModulePath
          }
          else {
            Write-Host "NOT EXIST"
          }
 
      - name: ENV
        run: |
          Write-Host "ModulePath: '$ENV:PSModulePath'"
          Write-Host "GITHUB_EVENT_PATH: '$ENV:GITHUB_EVENT_PATH'"
          Get-Module Az.KeyVault -ListAvailable         
          Get-Module AzureRM.KeyVault -ListAvailable         

      - name: ENV
        run: |
          dir env:

      - name: mask
        run: |
          Write-Host -nonewline "This is a test"
          Write-Host "`r::add-mask::Freddy"

      - name: print
        run: |
          Write-Host "Freddy Kristiansen"

      - name: event
        run: |
          Get-Content "$ENV:GITHUB_EVENT_PATH" -encoding UTF8

      - name: Echo on private
        run: echo "I am private"
        if: ${{github.event.repository.private}}

      - name: GCI
        run: |
          Get-ChildItem 'c:\modules' -recurse | out-host

  update2:
    runs-on: windows-latest

    steps:
      - name: ComputerInfo
        run: |
          Get-ComputerInfo | Out-Host

      - name: DownloadTest
        run: |
          $ProgressPreference = "SilentlyContinue"
          function DownloadFileLow {
              Param(
                  [string] $sourceUrl,
                  [string] $destinationFile,
                  [switch] $dontOverwrite,
                  [switch] $useDefaultCredentials,
                  [hashtable] $headers = @{"UserAgent" = "BcContainerHelper $bcContainerHelperVersion" },
                  [int] $timeout = 100
              )
          
              if ($useDefaultCredentials) {
                  $handler = New-Object System.Net.Http.HttpClientHandler
                  $handler.UseDefaultCredentials = $true
                  $httpClient = New-Object System.Net.Http.HttpClient -ArgumentList $handler
              }
              else {
                  $httpClient = New-Object System.Net.Http.HttpClient
              }
              $httpClient.Timeout = [Timespan]::FromSeconds($timeout)
              $headers.Keys | ForEach-Object {
                  $httpClient.DefaultRequestHeaders.Add($_, $headers."$_")
              }
              $stream = $null
              $fileStream = $null
              if ($dontOverwrite) {
                  $fileMode = [System.IO.FileMode]::CreateNew
              }
              else {
                  $fileMode = [System.IO.FileMode]::Create
              }
              try {
                  $stream = $httpClient.GetStreamAsync($sourceUrl).GetAwaiter().GetResult()
                  $fileStream = New-Object System.IO.Filestream($destinationFile, $fileMode)
                  $stream.CopyToAsync($fileStream).GetAwaiter().GetResult() | Out-Null
                  $fileStream.Close()
              }
              finally {
                  if ($fileStream) {
                      $fileStream.Dispose()
                  }
                  if ($stream) {
                      $stream.Dispose()
                  }
              }
          }
          Measure-Command {
            DownloadFileLow -sourceUrl 'https://bcartifacts.blob.core.windows.net/onprem/19.14.49970.0/us' -DestinationFile 'tmp.tmp'
          }

      - name: ENV
        run: |
          Write-Host "ModulePath: '$ENV:PSModulePath'"
          Write-Host "GITHUB_EVENT_PATH: '$ENV:GITHUB_EVENT_PATH'"
          Get-Module Az.KeyVault -ListAvailable         
          Get-Module AzureRM.KeyVault -ListAvailable         

  update3:
    runs-on: ubuntu-latest

    steps:
      - name: ComputerInfo
        run: |
          cat /proc/meminfo
          sudo lshw

      - name: DownloadTest
        run: |
          $ProgressPreference = "SilentlyContinue"
          function DownloadFileLow {
              Param(
                  [string] $sourceUrl,
                  [string] $destinationFile,
                  [switch] $dontOverwrite,
                  [switch] $useDefaultCredentials,
                  [hashtable] $headers = @{"UserAgent" = "BcContainerHelper $bcContainerHelperVersion" },
                  [int] $timeout = 100
              )
          
              if ($useDefaultCredentials) {
                  $handler = New-Object System.Net.Http.HttpClientHandler
                  $handler.UseDefaultCredentials = $true
                  $httpClient = New-Object System.Net.Http.HttpClient -ArgumentList $handler
              }
              else {
                  $httpClient = New-Object System.Net.Http.HttpClient
              }
              $httpClient.Timeout = [Timespan]::FromSeconds($timeout)
              $headers.Keys | ForEach-Object {
                  $httpClient.DefaultRequestHeaders.Add($_, $headers."$_")
              }
              $stream = $null
              $fileStream = $null
              if ($dontOverwrite) {
                  $fileMode = [System.IO.FileMode]::CreateNew
              }
              else {
                  $fileMode = [System.IO.FileMode]::Create
              }
              try {
                  $stream = $httpClient.GetStreamAsync($sourceUrl).GetAwaiter().GetResult()
                  $fileStream = New-Object System.IO.Filestream($destinationFile, $fileMode)
                  $stream.CopyToAsync($fileStream).GetAwaiter().GetResult() | Out-Null
                  $fileStream.Close()
              }
              finally {
                  if ($fileStream) {
                      $fileStream.Dispose()
                  }
                  if ($stream) {
                      $stream.Dispose()
                  }
              }
          }
          Measure-Command {
            DownloadFileLow -sourceUrl 'https://bcartifacts.blob.core.windows.net/onprem/19.14.49970.0/us' -DestinationFile 'tmp.tmp'
          }
